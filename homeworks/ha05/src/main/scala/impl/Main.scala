package impl

import components.traits.{HeaderHolder, MethodHolder}
import util.{Data, Method}
import util.Method.{GET, Method}


object Main {

  def main(args: Array[String]): Unit = {
    val data = Data.readMessages("HttpMessages.csv")
    println("Read " + data.length + " lines.")

    // Aufgabe 5.1

    val messages = parseHttpMessages(data)
    if (messages.isEmpty) return


    // Aufgabe 5.2

    val getRequestCount = countGetRequests(messages.getOrElse(List()))
    println("getRequestCount: " + getRequestCount.orNull)

    val requestsWithoutResponse = findRequestsWithoutResponse(messages.orNull)
    println("requestsWithoutResponse: " + requestsWithoutResponse.orNull)
    println("requestsWithoutResponse length: " + requestsWithoutResponse.orNull.length)

    val eachIdempotentRequestTypeCount = countEachIdempotentRequestType(messages.orNull)
    println("eachIdempotentRequestTypeCount: " + eachIdempotentRequestTypeCount.orNull)

    val mostCommonHeader = findMostCommonHeader(messages.orNull)
    println("mostCommonHeader: " + mostCommonHeader.orNull)

    val eachHeaderCount = countEachHeader(messages.orNull)
    println("eachHeaderCount: " + eachHeaderCount.orNull)
    println("eachHeaderCount length: " + eachHeaderCount.orNull.length)

    val averageResponseContentLength = calculateAverageResponseContentLength(messages.orNull)
    println("averageResponseContentLength: " + averageResponseContentLength.orNull)

    val totalResponseContentLength = calculateTotalResponseContentLength(messages.orNull)
    println("totalResponseContentLength: " + totalResponseContentLength.orNull)
  }

  /////////////////
  // Aufgabe 5.1 //
  /////////////////

  /**
   * Parses the output of util.Data.read() to a list of HttpMessage objects by employing the factory pattern implemented in HttpMessage.
   * Refer to lecture slides chapter 6.4 for details on the factory pattern.
   *
   * @param rawList Raw representation of dataset as generated by util.Data.read(). Nullable.
   * @return List of HttpMessages where requests are of type HttpRequest and responses are of type HttpResponse, or None if the input is null.
   */
  def parseHttpMessages(rawList: List[List[String]]): Option[List[HttpMessage]] = {
    Option(rawList.map(row => HttpMessage(row)))
  }

  /////////////////
  // Aufgabe 5.2 //
  /////////////////

  /**
   * Aufgabe 5.2.1: Berechnen Sie die Anzahl der Requests mit der Methode GET.
   * ------------
   *
   * Returns the number of GET-Requests in the dataset.
   *
   * @param messages List of HttpMessages comprising requests and their responses.
   * @return number of requests with the method GET.
   */
  def countGetRequests(messages: List[HttpMessage]): Option[Int] = {
    Option(
      messages
        .filter(message => message.isInstanceOf[HttpRequest])
        .map(message => message.asInstanceOf[HttpRequest])
        .count(request => request.method == Method.GET)
    )
  }

  /**
   * Aufgabe 5.2.2: Geben Sie die IDs aller Requests aus, die KEINEN Response mit der selben reqResId haben.
   * ------------
   *
   * Find the requests that don't have a response and return their IDs. A request has either no or one response,
   * whereas a response must have exactly one request associated with it. Associations are represented with the reqResId:
   * each request-response pair has a unique reqResId (even if there is no response to a request).
   *
   * @param messages List of HttpMessages comprising requests and their responses.
   * @return list of IDs of requests without responses.
   */
  def findRequestsWithoutResponse(messages: List[HttpMessage]): Option[List[Int]] = {
    Option(
      messages
        .filter(message => message.isInstanceOf[HttpRequest])
        .map(message => message.asInstanceOf[HttpRequest])
        .filter(request => messages
          .filter(message => message.isInstanceOf[HttpResponse])
          .map(message => message.asInstanceOf[HttpResponse])
          .forall(response => request.reqResId != response.reqResId)
        )
        .map(request => request.id)
    )
  }

  /**
   * Aufgabe 5.2.3: Geben Sie für jede im Datensatz vorhandene idempotente Request-Methode an, wie oft sie vorkommt.
   * ------------
   *
   * Counts the occurrence of requests with idempotent methods.
   *
   * @param messages List of HttpMessages comprising requests and their responses.
   * @return map of the idempotent methods present in the dataset and their count.
   */
  def countEachIdempotentRequestType(messages: List[HttpMessage]): Option[Map[Method, Int]] = {
    Option(
      messages
        .filter(message => message.isInstanceOf[HttpRequest])
        .map(message => message.asInstanceOf[HttpRequest])
        .filter(request => request.isIdempotent)
        .groupBy(request => request.method)
        .map(methodMap => (methodMap._1, methodMap._2.length))
    )
  }

  /**
   * Aufgabe 5.2.4: Finden Sie den Header-Key, der am häufigsten im Datensatz vorkommt.
   * ------------
   *
   * Finds the most common HTTP header in the dataset, i.e. the header that is present in the most HttpMessages.
   *
   * @param messages List of HttpMessages comprising requests and their responses.
   * @return key of the most common header.
   */
  def findMostCommonHeader(messages: List[HttpMessage]): Option[String] = {
    Option(messages
      .flatMap(message => message.headers.toList)
      .groupBy(tuple => tuple._1)
      .map(headersMap => (headersMap._1, headersMap._2.length))
      .maxBy(headersMap => headersMap._2)
      ._1
    )
  }

  /**
   * Aufgabe 5.2.5: Geben Sie für jeden im Datensatz vorhandenen Header-Key an, wie oft er vorkommt.
   * ------------
   *
   * Counts the occurence of each header key across every HttpMessage in the dataset.
   *
   * @param messages List of HttpMessages comprising requests and their responses.
   * @return list of tuples containing the header key and their count.
   */
  def countEachHeader(messages: List[HttpMessage]): Option[List[(String, Int)]] = {
    Option(messages
      .flatMap(message => message.headers.toList)
      .groupBy(tuple => tuple._1)
      .map(headersMap => (headersMap._1, headersMap._2.length))
      .toList
    )
  }

  /**
   * Aufgabe 5.2.6: Berechnen Sie die durchschnittliche Inhaltslänge (contentLength) aller Responses im Datensatz.
   * ------------
   *
   * Calculates the average (mean) content length of responses in the dataset.
   *
   * @param messages List of HttpMessages comprising requests and their responses.
   * @return the mean content length as a double value.
   */
  def calculateAverageResponseContentLength(messages: List[HttpMessage]): Option[Double] = {
    Option(messages
      .filter(message => message.isInstanceOf[HttpResponse])
      .map(message => message.contentLength)
      .sum.toDouble
      /
      messages.count(message => message.isInstanceOf[HttpResponse]).toDouble
    )
  }

  /**
   * Aufgabe 5.2.7: Berechnen Sie die Summe der Inhaltlängen (contentLength) aller Responses im Datensatz.
   * ------------
   *
   * Calculates the total content length of all responses in the dataset.
   *
   * @param messages List of HttpMessages comprising requests and their responses.
   * @return the total content length of all responses.
   */
  def calculateTotalResponseContentLength(messages: List[HttpMessage]): Option[Int] = {
    Option(messages
      .filter(message => message.isInstanceOf[HttpResponse])
      .map(message => message.contentLength)
      .sum
    )
  }
}